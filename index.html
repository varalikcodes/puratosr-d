resize: vertical;
}

    .download-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      background-color: #800000;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 30px;
      font-size: 0.95rem;
      cursor: pointer;
      font-family: 'Montserrat', sans-serif;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      display: none;
    }

    .download-btn:hover {
      background-color: #660000;
      transform: scale(1.05);
    }
  </style>
  .download-btn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 100;
    background-color: #800000;
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 30px;
    font-size: 0.95rem;
    cursor: pointer;
    font-family: 'Montserrat', sans-serif;
    box-shadow: 0 2px 10px rgba(0,0,0,0.15);
    transition: background-color 0.3s, transform 0.2s;
  }

  .download-btn:hover {
    background-color: #660000;
    transform: scale(1.05);
  }

</style>
</head>

<body>
@@ -188,7 +189,7 @@
</div>
</div>

  <button id="downloadDocxBtn" class="download-btn" onclick="downloadDocx()">Download Summary</button>
  <button id="downloadDocxBtn" class="btn download-btn" onclick="downloadDocx()">Download Summary</button> 

<script>
const questions = [
@@ -226,109 +227,132 @@
}

function renderQuestion() {
      const currentQuestion = questions[currentQuestionIndex];
      document.getElementById('question').innerHTML = currentQuestion.question;
      const optionsContainer = document.getElementById('options');
      optionsContainer.innerHTML = '';
      if (currentQuestion.options.length > 0) {
        optionsContainer.style.display = 'flex';
        currentQuestion.options.forEach((option, index) => {
          const button = document.createElement('button');
          button.className = 'btn';
          button.textContent = option;
          button.onclick = () => nextQuestion(index);
          optionsContainer.appendChild(button);
        });
      } else {
        optionsContainer.style.display = 'none';
      }
      document.getElementById('notes').value = notesMap[currentQuestionIndex] || '';
      updateProgressBar();
    const currentQuestion = questions[currentQuestionIndex];
    const optionsContainer = document.getElementById('options');
    const notesBox = document.getElementById('notes');
    const container = document.getElementById('container');
  
    // Set current question HTML
    document.getElementById('question').innerHTML = currentQuestion.question;
    optionsContainer.innerHTML = '';
  
    // Save current notes
    if (notesBox) {
      notesBox.value = notesMap[currentQuestionIndex] || '';
    }
  
    // Check if terminal (GO or NO-GO)
    const isEnd =
      currentQuestion.next.length === 1 &&
      currentQuestion.next[0] === -1;
  
    if (isEnd) {
      // Show summary directly
      showSummary();
      return;
}

  // Otherwise render options
  if (currentQuestion.options.length > 0) {
    optionsContainer.style.display = 'flex';
    currentQuestion.options.forEach((option, index) => {
      const button = document.createElement('button');
      button.className = 'btn';
      button.textContent = option;
      button.onclick = () => nextQuestion(index);
      optionsContainer.appendChild(button);
    });
  } else {
    optionsContainer.style.display = 'none';
  }

  updateProgressBar();
}


function nextQuestion(optionIndex) {
const currentQuestion = questions[currentQuestionIndex];
const answer = currentQuestion.options[optionIndex];
decisions.push({
question: stripHTML(currentQuestion.question),
answer: answer,
notes: document.getElementById('notes')?.value || ""
});
notesMap[currentQuestionIndex] = document.getElementById('notes')?.value || "";
const nextIndex = currentQuestion.next[optionIndex];
if (nextIndex !== -1) {
history.push(currentQuestionIndex);
currentQuestionIndex = nextIndex;
renderQuestion();
} else {
showSummary();
}
}

function returnQuestion() {
notesMap[currentQuestionIndex] = document.getElementById('notes')?.value || "";
if (history.length > 0) {
currentQuestionIndex = history.pop();
renderQuestion();
}
}

function startOver() {
history = [];
currentQuestionIndex = 0;
decisions = [];
notesMap = {};
document.getElementById('downloadDocxBtn').style.display = "none";
renderQuestion();
}

function updateProgressBar() {
const totalSteps = questions.length;
const isTerminal = questions[currentQuestionIndex].next.length === 1 && questions[currentQuestionIndex].next[0] === -1;
const completedSteps = isTerminal ? totalSteps : Math.min(history.length + 1, totalSteps);
const progressPercent = (completedSteps / totalSteps) * 100;
document.getElementById('progressBar').style.width = `${progressPercent}%`;
}

function showSummary() {
document.getElementById('downloadDocxBtn').style.display = "block";
const container = document.getElementById('container');
container.innerHTML = `<div class="inner-title">Your Decision Path</div><ul id="decisionTree"></ul>`;
const list = document.getElementById('decisionTree');
list.style.textAlign = "left";
decisions.forEach((step, index) => {
const li = document.createElement('li');
li.innerHTML = `<strong>Q:</strong> ${step.question}<br><strong>A:</strong> ${step.answer}` + (step.notes ? `<br><strong>Notes:</strong> ${step.notes}` : "");
list.appendChild(li);
});
}

async function downloadDocx() {
const { Document, Packer, Paragraph, TextRun } = window.docx;
const doc = new Document();
doc.addSection({
properties: {},
children: decisions.map(step => new Paragraph({
children: [
new TextRun({ text: "Q: " + step.question, bold: true }),
new TextRun({ text: "\nA: " + step.answer, break: 1 }),
...(step.notes ? [new TextRun({ text: "\nNotes: " + step.notes, break: 1 })] : []),
new TextRun({ text: "\n", break: 1 })
]
}))
});

const blob = await Packer.toBlob(doc);
const link = document.createElement('a');
link.href = URL.createObjectURL(blob);
link.download = "decision-summary.docx";
link.click();
}

document.getElementById('returnBtn').onclick = returnQuestion;
document.getElementById('startOverBtn').onclick = startOver;

renderQuestion();
</script>
</body>
</html>
